{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Quaternion } from \"../../Maths/math.vector.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Listen to mouse events to control the camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FlyCameraMouseInput {\n  /**\n   * Listen to mouse events to control the camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n   */\n  constructor() {\n    /**\n     * Defines the buttons associated with the input to handle camera rotation.\n     */\n    this.buttons = [0, 1, 2];\n    /**\n     * Assign buttons for Yaw control.\n     */\n    this.buttonsYaw = [-1, 0, 1];\n    /**\n     * Assign buttons for Pitch control.\n     */\n    this.buttonsPitch = [-1, 0, 1];\n    /**\n     * Assign buttons for Roll control.\n     */\n    this.buttonsRoll = [2];\n    /**\n     * Detect if any button is being pressed while mouse is moved.\n     * -1 = Mouse locked.\n     * 0 = Left button.\n     * 1 = Middle Button.\n     * 2 = Right Button.\n     */\n    this.activeButton = -1;\n    /**\n     * Defines the pointer's angular sensibility, to control the camera rotation speed.\n     * Higher values reduce its sensitivity.\n     */\n    this.angularSensibility = 1000.0;\n    this._previousPosition = null;\n  }\n  /**\n   * Attach the mouse control to the HTML DOM element.\n   * @param noPreventDefault Defines whether events caught by the controls should call preventdefault().\n   */\n  attachControl(noPreventDefault) {\n    // eslint-disable-next-line prefer-rest-params\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    this._noPreventDefault = noPreventDefault;\n    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(p => {\n      this._pointerInput(p);\n    }, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\n    // Correct Roll by rate, if enabled.\n    this._rollObserver = this.camera.getScene().onBeforeRenderObservable.add(() => {\n      if (this.camera.rollCorrect) {\n        this.camera.restoreRoll(this.camera.rollCorrect);\n      }\n    });\n  }\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n  detachControl() {\n    if (this._observer) {\n      this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\n      this.camera.getScene().onBeforeRenderObservable.remove(this._rollObserver);\n      this._observer = null;\n      this._rollObserver = null;\n      this._previousPosition = null;\n      this._noPreventDefault = undefined;\n    }\n  }\n  /**\n   * Gets the class name of the current input.\n   * @returns the class name.\n   */\n  getClassName() {\n    return \"FlyCameraMouseInput\";\n  }\n  /**\n   * Get the friendly name associated with the input class.\n   * @returns the input's friendly name.\n   */\n  getSimpleName() {\n    return \"mouse\";\n  }\n  // Track mouse movement, when the pointer is not locked.\n  _pointerInput(p) {\n    const e = p.event;\n    const camera = this.camera;\n    const engine = camera.getEngine();\n    if (engine.isInVRExclusivePointerMode) {\n      return;\n    }\n    if (!this.touchEnabled && e.pointerType === \"touch\") {\n      return;\n    }\n    // Mouse is moved but an unknown mouse button is pressed.\n    if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(e.button) === -1) {\n      return;\n    }\n    const srcElement = e.target;\n    // Mouse down.\n    if (p.type === PointerEventTypes.POINTERDOWN) {\n      try {\n        srcElement === null || srcElement === void 0 ? void 0 : srcElement.setPointerCapture(e.pointerId);\n      } catch (e) {\n        // Nothing to do with the error. Execution continues.\n      }\n      this._previousPosition = {\n        x: e.clientX,\n        y: e.clientY\n      };\n      this.activeButton = e.button;\n      if (!this._noPreventDefault) {\n        e.preventDefault();\n        this._element.focus();\n      }\n      // This is required to move while pointer button is down\n      if (engine.isPointerLock) {\n        this._onMouseMove(p.event);\n      }\n    }\n    // Mouse up.\n    else if (p.type === PointerEventTypes.POINTERUP) {\n      try {\n        srcElement === null || srcElement === void 0 ? void 0 : srcElement.releasePointerCapture(e.pointerId);\n      } catch (e) {\n        // Nothing to do with the error. Execution continues.\n      }\n      this.activeButton = -1;\n      this._previousPosition = null;\n      if (!this._noPreventDefault) {\n        e.preventDefault();\n      }\n    }\n    // Mouse move.\n    else if (p.type === PointerEventTypes.POINTERMOVE) {\n      if (!this._previousPosition) {\n        if (engine.isPointerLock) {\n          this._onMouseMove(p.event);\n        }\n        return;\n      }\n      const offsetX = e.clientX - this._previousPosition.x;\n      const offsetY = e.clientY - this._previousPosition.y;\n      this._rotateCamera(offsetX, offsetY);\n      this._previousPosition = {\n        x: e.clientX,\n        y: e.clientY\n      };\n      if (!this._noPreventDefault) {\n        e.preventDefault();\n      }\n    }\n  }\n  // Track mouse movement, when pointer is locked.\n  _onMouseMove(e) {\n    const camera = this.camera;\n    const engine = camera.getEngine();\n    if (!engine.isPointerLock || engine.isInVRExclusivePointerMode) {\n      return;\n    }\n    const offsetX = e.movementX;\n    const offsetY = e.movementY;\n    this._rotateCamera(offsetX, offsetY);\n    this._previousPosition = null;\n    if (!this._noPreventDefault) {\n      e.preventDefault();\n    }\n  }\n  /**\n   * Rotate camera by mouse offset.\n   * @param offsetX\n   * @param offsetY\n   */\n  _rotateCamera(offsetX, offsetY) {\n    const camera = this.camera;\n    const scene = this.camera.getScene();\n    if (scene.useRightHandedSystem) {\n      offsetX *= -1;\n    }\n    if (camera.parent && camera.parent._getWorldMatrixDeterminant() < 0) {\n      offsetX *= -1;\n    }\n    const x = offsetX / this.angularSensibility;\n    const y = offsetY / this.angularSensibility;\n    // Initialize to current rotation.\n    const currentRotation = Quaternion.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, camera.rotation.z);\n    let rotationChange;\n    // Pitch.\n    if (this.buttonsPitch.some(v => {\n      return v === this.activeButton;\n    })) {\n      // Apply change in Radians to vector Angle.\n      rotationChange = Quaternion.RotationAxis(Axis.X, y);\n      // Apply Pitch to quaternion.\n      currentRotation.multiplyInPlace(rotationChange);\n    }\n    // Yaw.\n    if (this.buttonsYaw.some(v => {\n      return v === this.activeButton;\n    })) {\n      // Apply change in Radians to vector Angle.\n      rotationChange = Quaternion.RotationAxis(Axis.Y, x);\n      // Apply Yaw to quaternion.\n      currentRotation.multiplyInPlace(rotationChange);\n      // Add Roll, if banked turning is enabled, within Roll limit.\n      const limit = camera.bankedTurnLimit + camera._trackRoll; // Defaults to 90° plus manual roll.\n      if (camera.bankedTurn && -limit < camera.rotation.z && camera.rotation.z < limit) {\n        const bankingDelta = camera.bankedTurnMultiplier * -x;\n        // Apply change in Radians to vector Angle.\n        rotationChange = Quaternion.RotationAxis(Axis.Z, bankingDelta);\n        // Apply Yaw to quaternion.\n        currentRotation.multiplyInPlace(rotationChange);\n      }\n    }\n    // Roll.\n    if (this.buttonsRoll.some(v => {\n      return v === this.activeButton;\n    })) {\n      // Apply change in Radians to vector Angle.\n      rotationChange = Quaternion.RotationAxis(Axis.Z, -x);\n      // Track Rolling.\n      camera._trackRoll -= x;\n      // Apply Pitch to quaternion.\n      currentRotation.multiplyInPlace(rotationChange);\n    }\n    // Apply rotationQuaternion to Euler camera.rotation.\n    currentRotation.toEulerAnglesToRef(camera.rotation);\n  }\n}\n__decorate([serialize()], FlyCameraMouseInput.prototype, \"buttons\", void 0);\n__decorate([serialize()], FlyCameraMouseInput.prototype, \"angularSensibility\", void 0);\nCameraInputTypes[\"FlyCameraMouseInput\"] = FlyCameraMouseInput;","map":{"version":3,"mappings":"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","names":["serialize","CameraInputTypes","PointerEventTypes","Quaternion","Axis","Tools","FlyCameraMouseInput","constructor","attachControl","noPreventDefault","BackCompatCameraNoPreventDefault","arguments","_noPreventDefault","_observer","camera","getScene","_inputManager","_addCameraPointerObserver","p","_pointerInput","POINTERDOWN","POINTERUP","POINTERMOVE","_rollObserver","onBeforeRenderObservable","add","rollCorrect","restoreRoll","detachControl","_removeCameraPointerObserver","remove","_previousPosition","undefined","getClassName","getSimpleName","e","event","engine","getEngine","isInVRExclusivePointerMode","touchEnabled","pointerType","type","buttons","indexOf","button","srcElement","target","setPointerCapture","pointerId","x","clientX","y","clientY","activeButton","preventDefault","_element","focus","isPointerLock","_onMouseMove","releasePointerCapture","offsetX","offsetY","_rotateCamera","movementX","movementY","scene","useRightHandedSystem","parent","_getWorldMatrixDeterminant","angularSensibility","currentRotation","RotationYawPitchRoll","rotation","z","rotationChange","buttonsPitch","some","v","RotationAxis","X","multiplyInPlace","buttonsYaw","Y","limit","bankedTurnLimit","_trackRoll","bankedTurn","bankingDelta","bankedTurnMultiplier","Z","buttonsRoll","toEulerAnglesToRef","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Cameras/Inputs/flyCameraMouseInput.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FlyCamera } from \"../../Cameras/flyCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Quaternion } from \"../../Maths/math.vector\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Listen to mouse events to control the camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FlyCameraMouseInput implements ICameraInput<FlyCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FlyCamera;\r\n\r\n    /**\r\n     * Defines if touch is enabled. (Default is true.)\r\n     */\r\n    public touchEnabled: boolean;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera rotation.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Assign buttons for Yaw control.\r\n     */\r\n    public buttonsYaw: number[] = [-1, 0, 1];\r\n\r\n    /**\r\n     * Assign buttons for Pitch control.\r\n     */\r\n    public buttonsPitch: number[] = [-1, 0, 1];\r\n\r\n    /**\r\n     * Assign buttons for Roll control.\r\n     */\r\n    public buttonsRoll: number[] = [2];\r\n\r\n    /**\r\n     * Detect if any button is being pressed while mouse is moved.\r\n     * -1 = Mouse locked.\r\n     * 0 = Left button.\r\n     * 1 = Middle Button.\r\n     * 2 = Right Button.\r\n     */\r\n    public activeButton: number = -1;\r\n\r\n    /**\r\n     * Defines the pointer's angular sensibility, to control the camera rotation speed.\r\n     * Higher values reduce its sensitivity.\r\n     */\r\n    @serialize()\r\n    public angularSensibility = 1000.0;\r\n\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _rollObserver: Nullable<Observer<Scene>>;\r\n    private _previousPosition: Nullable<{ x: number; y: number }> = null;\r\n    private _noPreventDefault: boolean | undefined;\r\n    private _element: HTMLElement;\r\n\r\n    /**\r\n     * Listen to mouse events to control the camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     * Attach the mouse control to the HTML DOM element.\r\n     * @param noPreventDefault Defines whether events caught by the controls should call preventdefault().\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._noPreventDefault = noPreventDefault;\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver((p: any) => {\r\n            this._pointerInput(p);\r\n        }, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        // Correct Roll by rate, if enabled.\r\n        this._rollObserver = this.camera.getScene().onBeforeRenderObservable.add(() => {\r\n            if (this.camera.rollCorrect) {\r\n                this.camera.restoreRoll(this.camera.rollCorrect);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n\r\n            this.camera.getScene().onBeforeRenderObservable.remove(this._rollObserver);\r\n\r\n            this._observer = null;\r\n            this._rollObserver = null;\r\n            this._previousPosition = null;\r\n            this._noPreventDefault = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name.\r\n     */\r\n    public getClassName(): string {\r\n        return \"FlyCameraMouseInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input's friendly name.\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mouse\";\r\n    }\r\n\r\n    // Track mouse movement, when the pointer is not locked.\r\n    private _pointerInput(p: any): void {\r\n        const e = <IPointerEvent>p.event;\r\n\r\n        const camera = this.camera;\r\n        const engine = camera.getEngine();\r\n\r\n        if (engine.isInVRExclusivePointerMode) {\r\n            return;\r\n        }\r\n\r\n        if (!this.touchEnabled && e.pointerType === \"touch\") {\r\n            return;\r\n        }\r\n\r\n        // Mouse is moved but an unknown mouse button is pressed.\r\n        if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(e.button) === -1) {\r\n            return;\r\n        }\r\n\r\n        const srcElement = <HTMLElement>e.target;\r\n\r\n        // Mouse down.\r\n        if (p.type === PointerEventTypes.POINTERDOWN) {\r\n            try {\r\n                srcElement?.setPointerCapture(e.pointerId);\r\n            } catch (e) {\r\n                // Nothing to do with the error. Execution continues.\r\n            }\r\n\r\n            this._previousPosition = {\r\n                x: e.clientX,\r\n                y: e.clientY,\r\n            };\r\n\r\n            this.activeButton = e.button;\r\n\r\n            if (!this._noPreventDefault) {\r\n                e.preventDefault();\r\n                this._element.focus();\r\n            }\r\n\r\n            // This is required to move while pointer button is down\r\n            if (engine.isPointerLock) {\r\n                this._onMouseMove(p.event);\r\n            }\r\n        }\r\n        // Mouse up.\r\n        else if (p.type === PointerEventTypes.POINTERUP) {\r\n            try {\r\n                srcElement?.releasePointerCapture(e.pointerId);\r\n            } catch (e) {\r\n                // Nothing to do with the error. Execution continues.\r\n            }\r\n\r\n            this.activeButton = -1;\r\n\r\n            this._previousPosition = null;\r\n            if (!this._noPreventDefault) {\r\n                e.preventDefault();\r\n            }\r\n        }\r\n        // Mouse move.\r\n        else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n            if (!this._previousPosition) {\r\n                if (engine.isPointerLock) {\r\n                    this._onMouseMove(p.event);\r\n                }\r\n\r\n                return;\r\n            }\r\n\r\n            const offsetX = e.clientX - this._previousPosition.x;\r\n            const offsetY = e.clientY - this._previousPosition.y;\r\n\r\n            this._rotateCamera(offsetX, offsetY);\r\n\r\n            this._previousPosition = {\r\n                x: e.clientX,\r\n                y: e.clientY,\r\n            };\r\n\r\n            if (!this._noPreventDefault) {\r\n                e.preventDefault();\r\n            }\r\n        }\r\n    }\r\n\r\n    // Track mouse movement, when pointer is locked.\r\n    private _onMouseMove(e: any): void {\r\n        const camera = this.camera;\r\n        const engine = camera.getEngine();\r\n\r\n        if (!engine.isPointerLock || engine.isInVRExclusivePointerMode) {\r\n            return;\r\n        }\r\n\r\n        const offsetX = e.movementX;\r\n        const offsetY = e.movementY;\r\n\r\n        this._rotateCamera(offsetX, offsetY);\r\n\r\n        this._previousPosition = null;\r\n\r\n        if (!this._noPreventDefault) {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rotate camera by mouse offset.\r\n     * @param offsetX\r\n     * @param offsetY\r\n     */\r\n    private _rotateCamera(offsetX: number, offsetY: number): void {\r\n        const camera = this.camera;\r\n        const scene = this.camera.getScene();\r\n\r\n        if (scene.useRightHandedSystem) {\r\n            offsetX *= -1;\r\n        }\r\n\r\n        if (camera.parent && camera.parent._getWorldMatrixDeterminant() < 0) {\r\n            offsetX *= -1;\r\n        }\r\n\r\n        const x = offsetX / this.angularSensibility;\r\n        const y = offsetY / this.angularSensibility;\r\n\r\n        // Initialize to current rotation.\r\n        const currentRotation = Quaternion.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, camera.rotation.z);\r\n        let rotationChange: Quaternion;\r\n\r\n        // Pitch.\r\n        if (\r\n            this.buttonsPitch.some((v) => {\r\n                return v === this.activeButton;\r\n            })\r\n        ) {\r\n            // Apply change in Radians to vector Angle.\r\n            rotationChange = Quaternion.RotationAxis(Axis.X, y);\r\n            // Apply Pitch to quaternion.\r\n            currentRotation.multiplyInPlace(rotationChange);\r\n        }\r\n\r\n        // Yaw.\r\n        if (\r\n            this.buttonsYaw.some((v) => {\r\n                return v === this.activeButton;\r\n            })\r\n        ) {\r\n            // Apply change in Radians to vector Angle.\r\n            rotationChange = Quaternion.RotationAxis(Axis.Y, x);\r\n            // Apply Yaw to quaternion.\r\n            currentRotation.multiplyInPlace(rotationChange);\r\n\r\n            // Add Roll, if banked turning is enabled, within Roll limit.\r\n            const limit = camera.bankedTurnLimit + camera._trackRoll; // Defaults to 90° plus manual roll.\r\n            if (camera.bankedTurn && -limit < camera.rotation.z && camera.rotation.z < limit) {\r\n                const bankingDelta = camera.bankedTurnMultiplier * -x;\r\n                // Apply change in Radians to vector Angle.\r\n                rotationChange = Quaternion.RotationAxis(Axis.Z, bankingDelta);\r\n                // Apply Yaw to quaternion.\r\n                currentRotation.multiplyInPlace(rotationChange);\r\n            }\r\n        }\r\n\r\n        // Roll.\r\n        if (\r\n            this.buttonsRoll.some((v) => {\r\n                return v === this.activeButton;\r\n            })\r\n        ) {\r\n            // Apply change in Radians to vector Angle.\r\n            rotationChange = Quaternion.RotationAxis(Axis.Z, -x);\r\n            // Track Rolling.\r\n            camera._trackRoll -= x;\r\n            // Apply Pitch to quaternion.\r\n            currentRotation.multiplyInPlace(rotationChange);\r\n        }\r\n\r\n        // Apply rotationQuaternion to Euler camera.rotation.\r\n        currentRotation.toEulerAnglesToRef(camera.rotation);\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FlyCameraMouseInput\"] = FlyCameraMouseInput;\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}